package ls

import (
	"testing"

	"github.com/sebasttiano/gobmp/pkg/base"
	"github.com/sebasttiano/gobmp/pkg/srv6"
	"github.com/sebasttiano/gobmp/pkg/te"
)

func TestLSNLRI71(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		nlri     NLRI71
		fail     bool
		elements []Element
	}{
		{
			name:  "ls node update",
			input: []byte{0x00, 0x01, 0x00, 0x27, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0xE8, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			fail:  false,
			elements: []Element{
				{
					Type: 1,
					LS:   &base.NodeNLRI{},
				},
			},
		},
		{
			name:  "ls link update",
			input: []byte{0x00, 0x02, 0x00, 0x73, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0xE8, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0xE8, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x05, 0x00, 0x10, 0xFC, 0x00, 0xDD, 0xDD, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x06, 0x00, 0x10, 0xFC, 0x00, 0xDD, 0xDD, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x07, 0x00, 0x02, 0x00, 0x02},
			fail:  false,
			elements: []Element{
				{
					Type: 2,
					LS:   &base.LinkNLRI{},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n, err := UnmarshalLSNLRI71(tt.input)
			if err != nil && !tt.fail {
				t.Fatalf("test should succeed but failed with error: %+v", err)
			}
			if err == nil && tt.fail {
				t.Fatalf("test should fail but succeeded")
			}
			if err != nil {
				return
			}
			for i, e := range n.NLRI {
				if tt.elements[i].Type != e.Type {
					t.Fatalf("computed %d and expected %d nlri types do not match", e.Type, tt.elements[i].Type)
				}
				switch tt.elements[i].Type {
				case 1:
					n, ok := e.LS.(*base.NodeNLRI)
					if !ok {
						t.Fatalf("Unrecognzed NodeNLRI object")
					}
					t.Logf("Node: %+v", n)
					t.Logf("Node Descriptor: %+v", n.LocalNode)
				case 2:
					l, ok := e.LS.(*base.LinkNLRI)
					if !ok {
						t.Fatalf("Unrecognzed LinkNLRI object")
					}
					t.Logf("Link: %+v", l)
					t.Logf("Local Node Descriptor: %+v", l.LocalNode)
					t.Logf("Remote Node Descriptor: %+v", l.RemoteNode)
				case 3:
					fallthrough
				case 4:
					t.Logf("NLRI element: %+v", e.LS.(*base.PrefixNLRI))
				case 5:
					t.Logf("NLRI element: %+v", e.LS.(*te.NLRI))
				case 6:
					t.Logf("NLRI element: %+v", e.LS.(*srv6.SIDNLRI))
				default:
					t.Fatalf("non supported NLRI type: %d", tt.elements[i].Type)
				}

			}
		})
	}
}
